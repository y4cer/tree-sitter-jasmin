qident ::= NID (COLONCOLON NID)*

ident ::= loc(<qident)>

var ::= ident

keyword ::= 'inline'
            | 'export'
            | 'reg'
            | 'stack'

annotationlabel ::= ident
                    | loc(<keyword)>
                    | loc('string')

int ::= INT
        | '-' INT

simple_attribute ::= int
                     | NID
                     | 'string'
                     | keyword
                     | utype

attribute ::= '=' loc(<simple_attribute)>
              | '=' loc(<braces(<struct_annot)>)>

annotation ::= annotationlabel [attribute]

struct_annot ::= [annotation (',' annotation)*]

top_annotation ::= '#' annotation
                   | '#' '[' struct_annot ']'

annotations ::= top_annotation*

utype ::= 'u8'
          | 'u16'
          | 'u32'
          | 'u64'
          | 'u128'
          | 'u256'

ptype_r ::= 'bool'
            | 'int'
            | utype
            | utype brackets(<pexpr)>

ptype ::= loc(<ptype_r)>

swsize ::= SWSIZE

svsize ::= SVSIZE

castop1 ::= swsize
            | svsize

castop ::= [loc(<castop1)>]

cast ::= 'int'
         | swsize

peop1 ::= '!' castop
          | '-' castop

peop2 ::= '&&'
          | '!!'
          | '+' castop
          | '-' castop
          | '*' castop
          | '/' castop
          | '%' castop
          | '&' castop
          | '|' castop
          | '^' castop
          | '<<' castop
          | loc('>>[su]?') castop
          | ROR castop
          | ROL castop
          | '==' castop
          | '!=' castop
          | loc('<[su]?') castop
          | loc('<=[su]?') castop
          | loc('>[su]?') castop
          | loc('>=[su]?') castop

prim ::= '#' ident

mem_ofs ::= '+' pexpr
            | '-' pexpr

unaligned ::= ALIGNED
              | UNALIGNED

mem_access ::= [parens(<utype)>] '[' [unaligned] var [mem_ofs]
                 ']'

arr_access_len ::= ':' pexpr

arr_access_i ::= [unaligned] [utype] pexpr [arr_access_len]

arr_access ::= ['.'] brackets(<arr_access_i)>

pexpr_r ::= var
            | var arr_access
            | 'true'
            | 'false'
            | INT
            | mem_access
            | parens(<svsize)> '[' rtuple1(<pexpr)> ']'
            | parens(<cast)> pexpr
            | peop1 pexpr
            | pexpr peop2 pexpr
            | parens(<pexpr)>
            | var parens_tuple(<pexpr)>
            | prim parens_tuple(<pexpr)>
            | pexpr '?' pexpr ':' pexpr

pexpr ::= loc(<pexpr_r)>

peqop ::= '='
          | '+' castop '='
          | '-' castop '='
          | '*' castop '='
          | '/' castop '='
          | '%' castop '='
          | loc('>>[su]?') castop '='
          | '<<' castop '='
          | ROR castop '='
          | ROL castop '='
          | '&' castop '='
          | '^' castop '='
          | '|' castop '='

plvalue_r ::= '_'
              | var
              | var arr_access
              | mem_access

plvalue ::= loc(<plvalue_r)>

implicites ::= '?' loc(<braces(<struct_annot)>)>

plvalues ::= tuple1(<plvalue)>
             | '(' ')'
             | implicites
             | implicites ',' rtuple1(<plvalue)>

pinstr_r ::= 'ArrayInit' parens(<var)> ';'
             | plvalues peqop pexpr [prefix('if', <pexpr)>] ';'
             | loc(<var parens_tuple(<pexpr)>)> [prefix('if', <pexpr)>]
               ';'
             | pif
             | 'for' var '=' pexpr 'to' pexpr pblock
             | 'for' var '=' pexpr 'downto' pexpr pblock
             | 'while' [pblock] '(' pexpr ')'
             | 'while' [pblock] '(' pexpr ')' pblock
             | postfix(<pvardecl([',']), ';')>

pif ::= 'if' pexpr pblock
        | 'if' pexpr pblock 'else' pelse

pelseif ::= loc(<pif)>

pelse ::= loc(<pelseif)>
          | pblock

pinstr ::= annotations loc(<pinstr_r)>

pblock_r ::= braces(<pinstr*)>

pblock ::= loc(<pblock_r)>

stor_type ::= storage ptype

annot_stor_type ::= annotations stor_type

writable ::= 'const'
             | 'mut'

pointer ::= [writable] 'ptr'

ptr ::= [pointer]

storage ::= 'reg' ptr
            | 'stack' ptr
            | 'inline'
            | 'global'

pvardecl(S) ::= stor_type var (S var)*

annot_pvardecl ::= annotations pvardecl(<empty)>

pfunbody ::= '{' pinstr* ['return' tuple(<var)> ';'] '}'

call_conv ::= 'export'
              | 'inline'

pfundef ::= annotations [call_conv] 'fn' ident
              parens_tuple(<annot_pvardecl)> [<prefix('->',
              tuple(<annot_stor_type)>)>] pfunbody

pparam ::= 'param' ptype ident '=' pexpr ';'

pgexpr ::= pexpr
           | '{' rtuple1(<pexpr)> '}'
           | loc('string')

pglobal ::= ptype ident '=' pgexpr ';'

pexec ::= 'exec' ident parens_tuple(<range)>

range ::= INT ':' INT

prequire1 ::= loc('string')

from ::= 'from' ident

prequire ::= [from] 'require' prequire1+

top ::= pfundef
        | pparam
        | pglobal
        | pexec
        | prequire
        | NAMESPACE ident '{' loc(<top)>* '}'

module_ ::= loc(<top)>* EOF
            | error

empty ::= epsilon

plist1(X, S) ::= X (S X)*

loc(X) ::= X

prefix(S, X) ::= S X

postfix(X, S) ::= X S

parens(X) ::= '(' X ')'

brackets(X) ::= '[' X ']'

braces(X) ::= '{' X '}'

rtuple(X) ::= [X (',' X)*]

rtuple1(X) ::= X (',' X)*

tuple(X) ::= parens(<rtuple(X))>
             | rtuple(X)

tuple1(X) ::= parens(<rtuple1(X))>
              | rtuple1(X)

parens_tuple(X) ::= parens(<rtuple(X))>

brackets_tuple(X) ::= brackets(<rtuple(X))>


